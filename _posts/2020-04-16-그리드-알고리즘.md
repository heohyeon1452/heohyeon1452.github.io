---
layout: single
title: "그리드 알고리즘"
date: 2020-04-16 09:00:00 +09:00
categories: INU Homework 백준 그리디
use_math: true

---

## 그리디 알고리즘 

> 다양한 경우의 수 중에서 가장 최단 혹은 최소의 경우의 수를 찾는 알고리즘이다. 

> 최대이윤 혹은 효율을 찾으려고 할 때 사용하는 알고리즘이다.



## 문제 설명 및 접근법



![도서관 문제](https://user-images.githubusercontent.com/62735361/79448370-45666700-801c-11ea-9386-bbeb7c2b7746.PNG)





##### 문제 확인

> 세준은 x선상에 놓여있는 책들을 꽂아야 하며, 한번에 M개의 책을 들을수 있다. 
>
> 이러할 때 최소한으로 움직이면서 책을 넣는 알고리즘을 해결하면된다.



##### 문제 접근법

> 우선 간단하게 접근을 하면 세준은 자신을 중심으로 오른쪽 왼쪽 움직이는 것은 비효율 적이다. 
>
>  즉 양수부분을 먼저 꽂은 후에 음수부분을 접근해야 한다.

> 마지막에 꽂은 후에는 돌아올 필요가 없다. 즉 마지막에는 왕복하지 않는다.



## 소스코드

```Java
 BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");

        int N = Integer.parseInt(str[0]);
        int M = Integer.parseInt(str[1]);
        str = br.readLine().split(" ");
```



처음에 Scanner 와 같이 버퍼를 이용하여 입력을 받아온다.

책 개수는 N이고 한번에 들수 있는 책은 M이다. " "를 기준으로 띄워져서 입력된다.



```JAVa
Queue<Integer> pos_q = new PriorityQueue<Integer>((x, y) -> y - x);
        Queue<Integer> neg_q = new PriorityQueue<Integer>();

        for (int i = 0; i < N; i++) {
            if (Integer.parseInt(str[i]) > 0) {
                pos_q.add(Integer.parseInt(str[i]));
            } else {
                neg_q.add(Integer.parseInt(str[i]));

            }
        }
```



양수값과 음수값을 나누어서 생각을 하기 위해서 다음과 같이 영역을나누어준다. 

```
int element;
        int max = 0;
        int sum = 0;
        while (!pos_q.isEmpty()) {
            for (int i = 0; i < M; i++) {
                if (pos_q.isEmpty())
                    continue;
                element = pos_q.poll();

                if (i == 0) {
                    sum += Math.abs(element);
                    if (Math.abs(element) > max) {
                        max = Math.abs(element);
                    }
                }
            }
        }
```



양수값에 있는 책들이 없어질 때까지 다음과 같은 식을 반복해준다.

중간에 continue를 하는 이유는 꽂아야 하는 책이 들수 있는 책보다 적을 때에 끊기지 않기 위해서이다.

i가 0일 때에는 거리가 가장 먼곳이므로 이때에만 거리를 더해주면 된다.





반복해서 음수 부분도 진행해준다.

```java

  while (!neg_q.isEmpty()) {
            for (int i = 0; i < M; i++) {
                
                if (neg_q.isEmpty())
                    continue;
                element = neg_q.poll();

               
                if (i == 0) {
                    sum += Math.abs(element);
                    if (Math.abs(element) > max) {
                        max = Math.abs(element);
                    }
                }
            }
        }
```







### 간단하게 설명 

> 최종적인 값은 sum*2 -max의 값이 출력된다. 그 이유는 M권씩 들고가면서 왔다갔다하는 (왕복)의 값에다가 마지막에 넣는 max값을 한번 빼주면 마지막에 되돌아 오지 않아도 되는 식이 되는것이다.







## 변형 및 생각해보기

![그리드 문제](https://user-images.githubusercontent.com/62735361/79456427-76996400-8029-11ea-81d6-2cc57b092729.jpg)



## 최단거리



다음과 같은 점들이 있는 좌표에서 최단 거리 혹은 최소거리를 찾은 알고리즘을 구현해 보려고 한다



(시간이 많지 않아서 간단히 생각만 하고 넘어가려고 합니다.)

배열을 이용해서 A[][] [] [] 와 같이 x,y 좌표가 들어온다면. 그 값은 양수 혹은 음수일 겁니다.



제가 생각한 알고리즘은 각 x,y의 절대값을 더한 값이 가장 멀리 있을 거라고 생각하는 알고리즘입니다.

다만 여기서 3과 5번은 똑같이 상하좌우로 5번을 이동 했지만 거리는 다음과 같습니다.
$$
X_{3}= (3^2 + 2^2)^{1/2}\\
X_{5}= (1^2 + 4^2)^{1/2}
$$


그렇기 때문에 각 좌표의 합이 아닌 제곱된 값의 합의 결과를 사용하면 된다.

