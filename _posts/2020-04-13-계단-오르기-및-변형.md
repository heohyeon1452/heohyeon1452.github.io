---
layout: single
title: "계단 오르기 및 변형"
date: 2020-04-13 06:00 +0900
categories: INU Homework 백준 
use_math: true

---

## 계단 오르기

> 오늘 할 소스는 간단한 문제지만 변형이 자유로운 문제여서 가져와 봤습니다.
>
> 힌트를 주고 시작하자면 점화식을 생각하면서 하면 쉬울 거같습니다.
>
> ​	바로 시작 하죠!

## 문제 

![계단1](https://user-images.githubusercontent.com/62735361/79080034-942aad00-7d4d-11ea-864d-4cb5156956b6.PNG)![계단2](https://user-images.githubusercontent.com/62735361/79080036-955bda00-7d4d-11ea-86bc-d3c292938ad7.PNG)

백준 문제 중에 내가 풀 수 있을 만한 문제를 찾았다.

물론 쉽게 풀이할수는 없지만 이해하기 쉽게 코드를 설명하면서 이해하는 시간을 가지는 데 의의를 둔다.

---

## 문제 해석

>
>
>다음과 같이 계단에 있는 숫자를 더하면서 최종적으로 가장 큰 수의 점수를 얻어야 하는 문제이다. 하지만 조건 중에 계단을 한 번에 한 번씩 올라가는게, 아닌 두 세 번 정도 한 번에 올라갈수 있다. 그리고 최종적으로는 마지막 계단에 올라가야한다.

## 문제 접근하기

>
>
>문제를 접근할때 내가 과연 한번 올라가는게 유리한지, 두번 올라가는게 유리한지 비교하면서 올라가는 문제이다. 즉 수식을 써보면

$$
A_{초기값}+A_{계단한번} \\A_{초기값}+A_{계단 두번}
$$

> 두 값을 비교하는 문장을 하나 만들어서 작성을 하면 됩니다.
>
> 또한 3번 연속되는 계단을 오를 수 없으므로 1,2,3계단이 안되고 1,2,4혹은 1,3,4 이런식으로 올라가야 한다는 점도 숙지하셔야합니다.



## 코드 작성하기

```java
import java.util.*;

class Stair{
    public static void main(String[] args){
        Scanner input = new Scanner(System.in);
        int n = input.nextInt();
        int stair[] = new int[n+1];
        //입력값을 받아옵니다.
        int[] result = new int[n+1];
        for(int i= 1;i <n+1; i++){
            stair[i] = input.nextInt();
        }
        if(n>2){
            result[1] = stair[1];
            result[2] = stair[1]+ stair[2];
        }//계단이 2로 설정되어있는 경우
        else{
            if(n==1){
                System.out.println(stair[1]);
                return;
            }else{
                System.out.println(stair[1]+stair[2]);
                return;
                //계단이 1로 설정되어 있는경우
            }
            
        }
        for(int ㅑ =3; i <= n; i++){
            result[i] = Math.max(result[i-3] +stair[i-1] 			                +stair[i],result[i-2] +stair[i]);
            //계단이 현재자리에서 2칸 차이나는것과 계단이 현재위치에서 2칸 1칸 차이				나는걸 비교해서 최종값 입력	
        }
        System.out.println(result[n]);
    }
}
```

> 여기서 중점은 아마도 마지막 For문에 있는 비교가 가장 중요하지 않을까 생각한다.
>
> 

## 문제 변형해보기

> 다음문제를 조건부 확률 문제를 이용해서 변행 해 보겠다.
>
> 내가 생각한 문제는 다음과 같다.

>두 과목이 계단 형식처럼 ABABAB형식처럼 되어있을 때
>
>두 과목 (알고리즘)과(공업수학) 이 있을 때 한번 공부할 때마다 알고리즘은 5퍼센트를 이해하고 공업수학은 7퍼센트를 이해한다( 성적이 5점 7점 증가)고 한다. 공업수학은 80점을 맞아야하고 알고리즘은 70점을 맞아야한다. 어떤 방식을 이용해야 최고의 성적을 거두어 낼수 있을까? 
>
>두 과목중 하나만 달성하면 끝 (두 점수의 합이가장커야함)  (시간 제한없음)



> 내가 생각해도 매우 어려워 보인다.....

## 문제 접근하기

쉽게 생각하면 각계단을 한번씩 밟으면서 공업수학은 80점을 맞기 전에 알고리즘 점수를 최대한 끌어 올리거나, 알고리즘 70점 맞기 전에 공업수학을 최대한 끌어올리면 된다. 하지만 그 과정에서 공부하는 패턴이 계단형식일 뿐이다. 

공업수학80점 맞는 걸 기준으로 7*11한 후에 알고리즘을 13번하고 공업수학을 공부하면 

총점 84+65 = 149점이다.

알고리즘 70점을 맞는걸 기준으로 5*13한후에 공업수학 11번 하고 알고리즘을 공부하면

총점 70+77 =144점이다.



결국은 공업수학을 공부하면된다. 하지만 계단형식이라는걸 감안하면 다른 변수도존재할수 있다.

## 변형문제 코드 및 결과





![변형 알고리즘](https://user-images.githubusercontent.com/62735361/79081817-b9261c80-7d5b-11ea-83f8-5508558f8a6d.PNG)![변형 알고리즘 결과](https://user-images.githubusercontent.com/62735361/79081818-ba574980-7d5b-11ea-91a1-6da6cd0d15bf.PNG)

다음과 같은 알고리즘을 짜 보았지만 ,



성적이 한계점을 넘기기 전에 멈추는 코드를 작성하면 완성할거 같다.



조금더 프로그래밍 공부를 하고 완성해 보겠습니다.

ㅇㅅㅇ// 펭하~

